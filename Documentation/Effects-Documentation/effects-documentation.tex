\input{../preamble}

\begin{tldr}
	\todo{}
\end{tldr}

\sect{Structure}

\newcommand{\SubItem}[1]{\begin{itemize}\item{#1}\end{itemize}}

\begin{itemize}
	\item{\textbf{\code{EffectableComponent}s} are \code{ActorComponent}s that allow for delegation (effects). They have predefined places called ``\code{Outlet}s'' that allow for code modification. Think of \code{Outlet}s like electrical outlets waiting to be plugged into.
		\SubItem{Let's use \code{StatsComponent} as an example. Say we want a Pok\'{e}mon-style ``Adamant'' nature ($+$10\% PhA/$-$10\%SpA). One such place for modification is in the function \code{RecalculateStats}. \todo{Update picture!}}
		\begin{center}
			\includegraphics[scale=2.5]{recalculate-stats-code}
		\end{center}
		}
	\item{\textbf{\code{Outlet} arrays} are variables inside of \code{EffectableComponent}s. They hold \code{Outlet}s whose delegates execute when needed.
		\SubItem{\todo{Update this!} Let's use \code{StatsComponent}'s \code{AfterRecalculateStatsArray} in our example. In this case, after stats are recalculated (say, on level-up), the base PhA would increase by 10\% and the base SpA would decrease by 10\% (additively): }
		\begin{center}
			\includegraphics[scale=2.5]{adamant-code}
		\end{center}		 
		}
	\item{\textbf{\code{EffectComponent}s} are \code{ActorComponent}s that plug into \code{Outlet}s. These come in many forms, but an easy example is a \code{Buff}. \todo{Describe how this happens with pictures!}}
\end{itemize}

\sect{List of \code{EffectableComponent}s and \code{Outlet} Arrays}

The following tables show all implemented \code{EffectableComponent}s and their delegate arrays. Note the ``base name'' indicates existence of:

\begin{enumerate}
	\item{the delegate signature \code{FBaseNameSignature};}
	\item{the private before/after arrays of \code{Outlet}s: \\\code{TArray<FBaseNameOutlet> BeforeBaseName}; and}
	\item{a function for each before/after to execute the arrays: \code{ExecuteBeforeBaseName (...)}.}
	\item{\code{AddBeforeBaseName}, a function to add an \code{Outlet} to the private array \code{BeforeBaseName} (which also puts it in the right order based on priority).}
\end{enumerate}

\noindent Note that the philosophy applies to what is \textit{probable} rather than what is \textit{possible}. Hence the list meant to be practical rather than exhaustive.

\begin{longtblr}[
	caption = {Delegate Arrays for \code{AffinitiesComponent}},
	label = {delegate-arrays-affinitiescomponent},
]{
	colspec= {Q[r, wd=0.25\linewidth] Q[l, wd=0.35\linewidth] Q[l, wd=0.25\linewidth]},
	hline{1,Z} = {2pt},
	hlines,
	row{1} = {font=\bfseries},
}

	Delegate Array Base Name	& Parameters	& Note\\
	GetUnspentPoints			& \code{int\&} Unspent points\\
	SetUnpentPoints				& \code{int\&} Current unspent points\\
								& \code{int\&} Attempted value being set\\
	
\end{longtblr}

\begin{longtblr}[
	caption = {Delegate Arrays for \code{LevelComponent}},
	label = {delegate-arrays-levelcomponent},
]{
	colspec= {Q[r, wd=0.25\linewidth] Q[l, wd=0.35\linewidth] Q[l, wd=0.25\linewidth]},
	hline{1,Z} = {2pt},
	hlines,
	row{1} = {font=\bfseries},
}

	Delegate Array Base Name	& Parameters	& Note\\
	GetBaseExpYield				& \code{int} Unaltered base exp yield\\
	SetBaseExpYield				& \code{int} Unaltered base exp yield\\
								& \code{int\&} Attempted value being set\\
	GetExpYield					& \code{UStatsComponent*} Victorious Monster\\
								& \code{float\&} Awarded exp\\
	GetCumulativeExp			& \code{int\&} Current CXP\\
	SetCumulativeExp			& \code{int} Current CXP	& All other level/exp setters go through here!\\
								& \code{int\&} Attempted CXP\\
	AddExp						& \code{int} Current exp	& No GetExp (=GetLevel)\\
								& \code{int\&} Added exp\\
	SetLevel					& \code{int} Current level	& No GetLevel\\
								& \code{int\&} Attempted level\\
	MaxLevel					& \code{int\&} The maximum level	& This is a getter function only\\
	MinLevel					& \code{int\&} The minimum level	& This is a getter function only\\
\end{longtblr}


\begin{longtblr}[
	caption = {Delegate Arrays for \code{StatsComponent}},
	label = {delegate-arrays-statscomponent},
]{
	colspec= {Q[r, wd=0.25\linewidth] Q[l, wd=0.35\linewidth] Q[l, wd=0.25\linewidth]},
	hline{1,Z} = {2pt},
	hlines,
	row{1} = {font=\bfseries},
}

	Delegate Array Base Name	& Parameters	& Note\\
	RandomizeStats				& \code{int\&} Min base stat		& This is the one with four parameters, but is called by all others\\
								& \code{int\&} Max base stat\\
								& \code{int\&} Min base pairs\\
								& \code{int\&} Max base pairs\\
	RecalculateStats			& \code{FStat*} Each stat in the loop	& Rather than make each individual stat an \code{EffectableComponent}, you can go stat-by-stat here\\
								& \code{bool} If true, reset the current stats to match the newly-calculated permanent stats\\
	ModifyStat					& \code{FStat*} The stat being modified\\
								& \code{float\&} The value of modification\\
								& \code{EStatValueType\&} The value type (e.g., current or permanent)\\
								& \code{EModificationMode\&} E.g., additive or multiplicative\\
	
\end{longtblr}

\sect{Making Your Own Effects}

Suppose you want to make your own effect from scratch. \todo{Lay this out!}

\input{../postamble}