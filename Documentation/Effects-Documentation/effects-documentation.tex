\input{../preamble}

\begin{tldr}
	\todo{}
\end{tldr}

\sect{Structure}

\newcommand{\SubItem}[1]{\begin{itemize}\item{#1}\end{itemize}}

\begin{itemize}
	\item{\textbf{\code{EffectableComponent}s} are \code{ActorComponent}s that allow for delegation (effects). They have predefined places called ``\code{Outlet}s'' that allow for code modification. Think of \code{Outlet}s like electrical outlets waiting to be plugged into.
		\SubItem{Let's use \code{StatsComponent} as an example. Say we want a Pok\'{e}mon-style ``Adamant'' nature ($+$10\% PhA/$-$10\%SpA). One such place for modification is in the function \code{RecalculateStats}. \todo{Update picture!}}
		\begin{center}
			\includegraphics[scale=2.5]{recalculate-stats-code}
		\end{center}
		}
	\item{\textbf{\code{Outlet} arrays} are variables inside of \code{EffectableComponent}s. They hold \code{Outlet}s whose delegates execute when needed.
		\SubItem{\todo{Update this!} Let's use \code{StatsComponent}'s \code{AfterRecalculateStatsArray} in our example. In this case, after stats are recalculated (say, on level-up), the base PhA would increase by 10\% and the base SpA would decrease by 10\% (additively): }
		\begin{center}
			\includegraphics[scale=2.5]{adamant-code}
		\end{center}		 
		}
	\item{\textbf{\code{EffectComponent}s} are \code{ActorComponent}s that plug into \code{Outlet}s. These come in many forms, but an easy example is a \code{Buff}. \todo{Describe how this happens with pictures!}}
\end{itemize}

\sect{List of \code{EffectableComponent}s and \code{Outlet} Arrays}

The following tables show all implemented \code{EffectableComponent}s and their delegate arrays. Note the ``base name'' indicates existence of:

\begin{enumerate}
	\item{the delegate signature \code{FBaseNameSignature};}
	\item{the private before/after arrays of \code{Outlet}s: \\\code{TArray<FBaseNameOutlet> BeforeBaseName}; and}
	\item{a function for each before/after to execute the arrays: \code{ExecuteBeforeBaseName (...)}.}
	\item{\code{AddBeforeBaseName}, a function to add an \code{Outlet} to the private array \code{BeforeBaseName} (which also puts it in the right order based on priority).}
\end{enumerate}

\noindent Note that the philosophy applies to what is \textit{probable} rather than what is \textit{possible}. Hence the list meant to be practical rather than exhaustive.

%--------------------------

\begin{longtblr}[
	caption = {Delegate Arrays for \code{AffinitiesComponent}},
	label = {delegate-arrays-affinitiescomponent},
]{
	colspec= {Q[r, wd=0.25\linewidth] Q[l, wd=0.35\linewidth] Q[l, wd=0.25\linewidth]},
	hline{1,Z} = {2pt},
	hlines,
	row{1} = {font=\bfseries},
}

	Base Name	& Parameters	& Note\\
	
\end{longtblr}

%--------------------------

\begin{longtblr}[
	caption = {Delegate Arrays for \code{LevelComponent}},
	label = {delegate-arrays-levelcomponent},
]{
	colspec= {Q[r, wd=0.25\linewidth] Q[l, wd=0.35\linewidth] Q[l, wd=0.25\linewidth]},
	hline{1,Z} = {2pt},
	hlines,
	row{1} = {font=\bfseries},
}

	Base Name		& Parameters	& Note\\
	BeforeSetCXP	& {	\code{const uint32 OldCXP},\\ 
						\code{int32\& AttemptedCXP}}	
					& \code{AttemptedCXP} is \code{int32\&} instead of \code{uint32\&} for Blueprint compatability.\\	
	AfterSetCXP		& {	\code{const uint32 OldCXP}\\ 
						\code{const uint32 NewCXP}} 
					& \code{UStatsComponent} subscribes to this in order to change stats on level change.\\
\end{longtblr}

%--------------------------

\begin{longtblr}[
	caption = {Delegate Arrays for \code{StatsComponent}},
	label = {delegate-arrays-statscomponent},
]{
	colspec= {Q[r, wd=0.25\linewidth] Q[l, wd=0.35\linewidth] Q[l, wd=0.25\linewidth]},
	hline{1,Z} = {2pt},
	hlines,
	row{1} = {font=\bfseries},
}

	Base Name	& Parameters	& Note\\
	
\end{longtblr}

\sect{Making Your Own Outlet}

As an example, let's use \code{BeforeGetBaseExpYield}. (You can imagine that this is an important Outlet for tweaking levelling curves.) Here's what to do:\\

\begin{enumerate}
	\item{\textbf{Go to the right directory.} We want to place the Outlet inside of \code{ULevelComponent}, so we'll go to that directory.}
	\item{\textbf{Copy + paste file.} The easiest way is to copy + paste pre-existing Outlets. In this example, we'll copy + paste \code{AfterSetCXPOutlet.h} and name the new file \code{BeforeGetBaseExpYield.h}. \\
	\begin{center}
		\includegraphics[scale=2]{create-outlet-rename}
	\end{center}
	}
	\item{\textbf{Replace old name.} Open the new file and you'll still see the base name ``AfterSetCXP'' everywhere. The easiest way is to do a find+replace ``AfterSetCXP'' $\rightarrow$ ``BeforeGetBaseExpYield''. This replaces everything from the \code{.generated} include to the delegate signature. If you're curious, you can look more in-depth and replace instances one-by-one.}
	\item{\textbf{Declare delegate signature.} In this case, we want the delegate signature to take two arguments: the original, unmodified yield and the one that will be returned from the \code{GetBaseExpYield} function.\\
	\begin{center}
		\includegraphics[scale=2]{create-outlet-signature}
	\end{center}
	\textit{Note: yours might use more than two parameters or different parameter types. Modify accordingly.}
	}
	\item{\textbf{Declare Outlet functions.} In order to be able to call \code{Execute} on your Outlet, you need to tell it a few things. The figure below displays a few things in red you should look at:\\
	\begin{center}
		\includegraphics[scale=2]{create-outlet-functions}
	\end{center}
		\begin{itemize}
			\item{Whether it's a \code{Before} or \code{After} type Outlet. This affects execution based on priority:
				\todo{Priority explanation}
			}
			\item{The parameters you defined in the delegate's signature. I know, I know---anytime you repeat code, you're probably doing something wrong. The biggest issue here is the UHT. If you have a better way of automating this, \textit{tell me!}}
		\end{itemize}
	}
\end{enumerate}

\sect{Making Your Own Effects}

Suppose you want to make your own effect from scratch. 

\input{../postamble}