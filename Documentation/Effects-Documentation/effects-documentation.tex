\input{../preamble}

\begin{tldr}
	\todo{}
\end{tldr}

\sect{Structure}

\newcommand{\SubItem}[1]{\begin{itemize}\item{#1}\end{itemize}}
\newcommand{\ScreenshotScale}{2.5}

\begin{itemize}
	\item{\textbf{\code{EffectableComponent}s} are \code{ActorComponent}s that allow for delegation (effects). They have predefined places called ``\code{Outlet}s'' that allow for code modification. Think of \code{Outlet}s like electrical outlets waiting to be plugged into.
		\SubItem{Let's use \code{StatsComponent} as an example. Say we want a Pok\'{e}mon-style ``Adamant'' nature ($+$10\% PhA/$-$10\%SpA). One such place for modification is in the function \code{RecalculateStats}. \todo{Update picture!}}
		\begin{center}
			\includegraphics[scale=\ScreenshotScale]{recalculate-stats-code}
		\end{center}
		}
	\item{\textbf{\code{Outlet} arrays} are variables inside of \code{EffectableComponent}s. They hold \code{Outlet}s whose delegates execute when needed.
		\SubItem{\todo{Update this!} Let's use \code{StatsComponent}'s \code{AfterRecalculateStatsArray} in our example. In this case, after stats are recalculated (say, on level-up), the base PhA would increase by 10\% and the base SpA would decrease by 10\% (additively): }
		\begin{center}
			\includegraphics[scale=\ScreenshotScale]{adamant-code}
		\end{center}		 
		}
	\item{\textbf{\code{EffectComponent}s} are \code{ActorComponent}s that plug into \code{Outlet}s. These come in many forms, but an easy example is a \code{Buff}. \todo{Describe how this happens with pictures!}}
\end{itemize}

\sect{List of \code{EffectableComponent}s and \code{Outlet} Arrays}

The following tables show all implemented \code{EffectableComponent}s and their delegate arrays. Note the ``base name'' indicates existence of:

\begin{enumerate}
	\item{the delegate signature \code{FBaseNameSignature};}
	\item{the private before/after arrays of \code{Outlet}s: \\\code{TArray<FBaseNameOutlet> BeforeBaseName}; and}
	\item{a function for each before/after to execute the arrays: \code{ExecuteBeforeBaseName (...)}.}
	\item{\code{AddBeforeBaseName}, a function to add an \code{Outlet} to the private array \code{BeforeBaseName} (which also puts it in the right order based on priority).}
\end{enumerate}

\noindent Note that the philosophy applies to what is \textit{probable} rather than what is \textit{possible}. Hence the list meant to be practical rather than exhaustive.

%--------------------------

\begin{longtblr}[
	caption = {Delegate Arrays for \code{LevelComponent}},
	label = {delegate-arrays-levelcomponent},
]{
	colspec= {Q[l, wd=0.13\linewidth] Q[l, wd=0.35\linewidth] Q[l, wd=0.37\linewidth]},
	hline{1,Z} = {2pt},
}
	\todo{Todo}
	
\end{longtblr}

%--------------------------

\newcommand{\DelegateSpace}{\hspace*{1em}$\blacktriangleright$}
\newcommand{\DelegateNote}{\hspace*{2em}\textit{Note:}}

\begin{longtblr}[
	caption = {Delegate Arrays for \code{LevelComponent}},
	label = {delegate-arrays-levelcomponent},
]{
	colspec= {Q[l, wd=0.13\linewidth] Q[l, wd=0.72\linewidth]},
	hline{1,Z} = {2pt},
}

	%----------------------
	\hline
	\SetCell[c=2]{l}{\color{ICBlue}\textbf{GetBaseExpYield}}\\
	\hline
	\\
	%----------------------	
	
	\DelegateSpace{} Before	
		& {	\code{const float OriginalYield},\\
			\code{float\& Yield}}
		\\
		
		
	\DelegateSpace{} After	
		& {	\code{const float OriginalYield},\\
			\code{const float ReturnedYield}}
		\\
		
	%----------------------
	\hline
	\SetCell[c=2]{l}{\color{ICBlue}\textbf{GetCXP}}\\
	\hline
	\\
	%----------------------	

	\DelegateSpace{} Before			
		& {	\code{const uint32 OriginalCXP},\\ 
			\code{int32\& ReturnedCXP}}	
		\\ 
	\DelegateNote{}
		& \code{ReturnedCXP} is \code{int32\&} instead of \code{uint32\&} for Blueprint compatability.
		\\		
							
	\DelegateSpace{} After				
		& {	\code{const uint32 OriginalCXP}\\ 
			\code{const int32 ReturnedCXP}} 
		\\ 
	\DelegateNote{}
		& \code{ReturnedCXP} is \code{const int32} instead of \code{const uint32} for Blueprint compatability.
		\\
		
	%----------------------
	\hline
	\SetCell[c=2]{l}{\color{ICBlue}\textbf{GetExpYield}}\\
	\hline
	\\
	%----------------------	

	\DelegateSpace{} Before			
		& {	\code{const float OriginalYield},\\ 
			\code{float\& ReturnedYield},\\
			\code{const uint16 DefeatedLevel},\\
			\code{const uint16 VictoriousLevel}
			}\\
		\\
	\DelegateNote{}
		& ``Defeated'' and ``Victorious'' levels are provided for flexibility (e.g., in case you want to yield exp differently based on level difference, although technically you could always back-calculate the level difference based on the equation and \code{OriginalYield}).
		\\		
							
	\DelegateSpace{} After			
		& {	\code{const float OriginalYied},\\ 
			\code{const float ReturnedYield},\\
			\code{const uint16 DefeatedLevel},\\
			\code{const uint16 VictoriousLevel}
			}\\
		\\
	\DelegateNote{}
		& ``Defeated'' and ``Victorious'' levels are provided for symmetry with respect to the ``Before'' delegate (since \code{ReturnedValue} is already calculated, I can't think of why you would need them, but you never know!).
		\\
		
	%----------------------
	\hline
	\SetCell[c=2]{l}{\color{ICBlue}\textbf{SetBaseExpYield}}\\
	\hline
	\\
	%----------------------	

	\DelegateSpace{} Before			
		& {	\code{const float OldYield},\\ 
			\code{float\& AttemptedYield}}	
		\\		
							
	\DelegateSpace{} After				
		& {	\code{const float OldYield}\\ 
			\code{const float NewYield}} 
		\\
		
	%----------------------
	\hline
	\SetCell[c=2]{l}{\color{ICBlue}\textbf{SetCXP}}\\
	\hline
	\\
	%----------------------	

	\DelegateSpace{} Before			
		& {	\code{const uint32 OldCXP},\\ 
			\code{int32\& AttemptedCXP}}	
		\\
	\DelegateNote{}
		& \code{AttemptedCXP} is \code{int32\&} instead of \code{uint32\&} for Blueprint compatability.
		\\		
							
	\DelegateSpace{} After				
		& {	\code{const uint32 OldCXP}\\ 
			\code{const uint32 NewCXP}} 
		\\
	\DelegateNote{}
		& \code{UStatsComponent} subscribes to this in order to change stats on level change.
		\\
		
		
		
\end{longtblr}

%--------------------------

\begin{longtblr}[
	caption = {Delegate Arrays for \code{LevelComponent}},
	label = {delegate-arrays-levelcomponent},
]{
	colspec= {Q[l, wd=0.13\linewidth] Q[l, wd=0.35\linewidth] Q[l, wd=0.37\linewidth]},
	hline{1,Z} = {2pt},
}

	\todo{Todo}
	
\end{longtblr}

%====================================================

\sect{Making Your Own Outlet}

As an example, let's use \code{BeforeGetBaseExpYield}. (You can imagine that this is an important Outlet for tweaking levelling curves.) Here's what to do:\\

\begin{enumerate}
	\item{\textbf{Plan ahead.} I would sincerely recommend you writing down what parameters your Outlet delegate takes on paper. We go to a few files and it's easy to be inconsistent.}
	\item{\textbf{Go to the right directory.} We want to place the Outlet inside of \code{ULevelComponent}, so we'll start with that directory. If it doesn't contain an ``Outlets'' directory, create one and place your Outlet(s) there.}
	\item{\textbf{Copy + paste file.} The easiest way is to copy + paste pre-existing Outlets. In this example, we'll copy + paste \code{SetCXPOutlet.h} and name the new file \code{GetBaseExpYield.h}. \\
	\begin{center}
		\includegraphics[scale=\ScreenshotScale]{create-outlet-rename}
	\end{center}
	\noindent \textit{Note: this includes both \code{BeforeGetBaseExpYield} and \code{AfterGetBaseExpYield} functionality, but we'll only talk about the ``Before'' variant.}
	}
	\item{\textbf{Replace old name.} Open the new file and you'll still see the base name ``SetCXP'' everywhere. The easiest way is to do a find+replace ``SetCXP'' $\rightarrow$ ``GetBaseExpYield''. This replaces everything from the \code{.generated} include to the delegate signature. If you're curious, you can look more in-depth and replace instances one-by-one.}
	\item{\textbf{Declare delegate signature.} In this case, we want the ``Before'' delegate signature to take two arguments: the original, unmodified yield and the one that will be returned from the \code{GetBaseExpYield} function.\\
	\begin{center}
		\includegraphics[scale=\ScreenshotScale]{create-outlet-signature}
	\end{center}
	You can also set the ``After'' signature in the same manner. \textit{Note: yours might use more than two parameters or different parameter types. Modify accordingly.}
	}
	\item{\textbf{Declare Outlet functions.} In order to be able to call \code{Execute} on your Outlet, you need to tell it a few things. The figure below displays a few things in red you should look at:\\
	\begin{center}
		\includegraphics[scale=\ScreenshotScale]{create-outlet-functions}
	\end{center}
		\begin{itemize}
			\item{Whether it's a \code{Before} or \code{After} type Outlet. This affects execution based on priority:
			\begin{tcolorbox}[colback=gray!20!white,colframe=blue!75!black,title=Priorities]
			
				The lower the priority, the farther away it is from execution. If two priorities are tied, the older effect is executed first. Order is set externally by EffectsComponent. Order:\\
				\begin{itemize}
					\item{Intrinsic ``before'' delegates (no Effect attached)}
					\item{``Before'' delegates:
						\begin{itemize}
							\item{Priority 1}
							\item{Priority 2.a (older)}
							\item{Priority 2.b (newer)}
							\item{...}
						\end{itemize}
						}
					\item{[Function executes]}
					\item{``After'' delegates:
						\begin{itemize}
							\item{...}
							\item{Priority 2.b (newer)}
							\item{Priority 2.a (older)}
							\item{Priority 1}
						\end{itemize}
						}
					\item{Intrinsic ``after'' delegates (have the final say)}
				\end{itemize}
				
			As an example, consider two delegates: one that says you can't take damage no matter what (call the \code{UBuff} ``Invincible'') and another that says damage against you can't be avoided no matter what (call the \code{UDebuff} ``Weakened''). What happens when the target takes damage? Well, it depends on priority:
			\begin{itemize}
				\item{They're probably subscribed to the Outlet in \code{UStatsComponent} called \code{BeforeModifyStat} with the target \code{FStat} being \code{Health}.}
				\item{Note that they're both ``Before'' delegates.}
				\item{Let's say Invincible has higher Priority. The result is the target takes damage because:
					\begin{enumerate}
						\item[1)]{Invincible first sets the damage to zero.}
						\item[2)]{Weakened then sets the damage to its original value.}
					\end{enumerate}
				}
				\item{If Weakened has higher Priority, the result is flipped and the target takes no damage.}
			\end{itemize}
	 
	 \end{tcolorbox}\vspace*{12pt}
			}
			\item{The parameters you defined in the delegate's signature. I know, I know---anytime you repeat code, you're probably doing something wrong. The biggest issue here is the UHT. The main (but not only) issue is that you can't have \code{UPROPERTY}s inside macros or the property won't register. If you have a better way of automating this, \textit{tell me!}}
			\item{Repeat for the ``After'' variant.}
		\end{itemize}
	}
	\item{\textbf{Check number of parameters.} I make a point of this because I find it's my most common error. Make sure your declared signature \textit{and} declared Outlet function macros have the correct number of params (two in our case). Explicitly, you might need to use \code{DECLARE\_DYNAMIC\_DELEGATE\_FourParams(...)}.}
	\item{\textbf{Declare \code{UPROPERTY}.} Inside the \code{UEffectableComponent} (in this example, \code{ULevelComponent}), declare the Outlet as a variable. Note that it's custom to have this \code{UPROPERTY} as public and in the ``Outlets'' category. It's also a good idea to comment the \code{UPROPERTY} with the parameters.
	\begin{center}
		\includegraphics[scale=\ScreenshotScale]{create-outlet-uproperty}
	\end{center}
	}
	\item{\textbf{Implement.} Now it's time to place your Outlet in the appropriate place(s). For our example, it's pretty simple: place it inside of \code{GetBaseExpYield} in \code{ULevelComponent}'s \code{.cpp} file.
	\begin{center}
		\includegraphics[scale=\ScreenshotScale]{create-outlet-cpp}
	\end{center}
	Note that you might have to do things like cache original values. Also, it may not appear necessary to have both ``Before'' and ``After'' Outlets in a function like this. However, it is still recommended to do so.
	}
	\item{\textbf{A note on complementary Outlets.} If you create a ``Before'' Outlet, you should also create an ``After'' Outlet. The biggest difference might be the delegate signature (e.g., reference ``\code{\&}'' to \code{const}).
		\begin{itemize}
			\item{An example where this would be necessary is an animation delegate. You only want to fire a ``bonus exp'' animation \textit{after} the amount of exp has been determined, checked, and is now constant.}
		\end{itemize}
	}
\end{enumerate}

\sect{Making Your Own Effects}

Suppose you want to make your own effect from scratch. \todo{todo}

\input{../postamble}