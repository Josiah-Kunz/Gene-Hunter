\input{../standalone}

\begin{tldr}
	\todo{}
\end{tldr}

%====================================================

\sect{Structure}

\newcommand{\SubItem}[1]{\begin{itemize}\item{#1}\end{itemize}}
\newcommand{\ScreenshotScale}{2.5}

\begin{itemize}
	\item{\textbf{\code{EffectableComponent}s} are \code{ActorComponent}s that allow for delegation (effects). They have predefined places called ``\code{Outlet}s'' that allow for code modification. Think of \code{Outlet}s like electrical outlets waiting to be plugged into.
		\SubItem{Let's use \code{StatsComponent} as an example. Say we want a Pok\'{e}mon-style ``Adamant'' nature ($+$10\% PhA/$-$10\%SpA). One such place for modification is in the function \code{RecalculateStats}. \todo{Update picture!}}
		\begin{center}
			\includegraphics[scale=\ScreenshotScale]{recalculate-stats-code}
		\end{center}
		}
	\item{\textbf{\code{Outlet} arrays} are variables inside of \code{EffectableComponent}s. They hold \code{Outlet}s whose delegates execute when needed.
		\SubItem{\todo{Update this!} Let's use \code{StatsComponent}'s \code{AfterRecalculateStatsArray} in our example. In this case, after stats are recalculated (say, on level-up), the base PhA would increase by 10\% and the base SpA would decrease by 10\% (additively): }
		\begin{center}
			\includegraphics[scale=\ScreenshotScale]{adamant-code}
		\end{center}		 
		}
	\item{\textbf{\code{EffectComponent}s} are \code{ActorComponent}s that plug into \code{Outlet}s. These come in many forms, but an easy example is a \code{Buff}. \todo{Describe how this happens with pictures!}}
\end{itemize}

%====================================================

\sect{\code{EffectComponent} Inheritance}

\input{effects-inheritance}



%====================================================

\sect{List of \code{EffectableComponent}s and \code{Outlet}s}

The following tables show all implemented \code{EffectableComponent}s and their delegate arrays. Note the ``base name'' indicates existence of ``Before'' and ``After'' versions of:

\begin{enumerate}
	\item{the delegate signatures, \code{FBeforeBaseNameSignature};}
	\item{the delegate wrappers, \code{FBeforeBaseNameDelegate}, which are necessary since \code{TArray}s cannot contain delegates;}
	\item{the private arrays of delegate wrappers,\\ \code{TArray<FBeforeBaseNameOutlet> BeforeDelegates};}
	\item{a function to execute the arrays, \code{ExecuteBeforeBaseName}; and}
	\item{\code{AddBeforeBaseName}, a function to add an \code{Outlet} to the private array \code{BeforeDelegates} (which also puts it in the right order based on priority).}
\end{enumerate}

\noindent Note that the philosophy applies to what is \textit{probable} rather than what is \textit{possible}. Hence the list meant to be practical rather than exhaustive.

%====================================================

\input{outlets-tables}

%====================================================

\sect{Making Your Own \code{Outlet}}

As an example, let's use \code{GetBaseExpYield}. (You can imagine that this is an important \code{Outlet} for tweaking levelling curves.) Here's what to do:\\

\begin{enumerate}
	\item{\textbf{Plan ahead.} I would sincerely recommend you writing down what parameters your \code{Outlet} \code{Before} and \code{After} delegates take on paper. We go to a few files and it's easy to be inconsistent.}
	\item{\textbf{Go to the right directory.} We want to place the \code{Outlet} inside of \code{ULevelComponent}, so we'll start with that directory. If yours doesn't contain an ``Outlets'' directory, create one and place your \code{Outlet}(s) there.}
	\item{\textbf{Copy + paste file.} The easiest way is to copy + paste pre-existing \code{Outlet}s. In this example, we'll copy + paste \code{SetCXPOutlet.h} and name the new file \code{GetBaseExpYield.h}. \\
	\begin{center}
		\includegraphics[scale=\ScreenshotScale]{create-outlet-rename}
	\end{center}
	\noindent \textit{Note: this includes both \code{BeforeGetBaseExpYield} and \code{AfterGetBaseExpYield} functionality. You don't have to make two different files!}
	}
	\item{\textbf{Replace old name.} Open the new file and you'll still see the base name ``SetCXP'' everywhere. The easiest way is to do a find+replace ``SetCXP'' $\rightarrow$ ``GetBaseExpYield''. This replaces everything from the \code{.generated} include to the delegate signatures. If you're curious, you can look more in-depth and replace instances one-by-one.}
	\item{\textbf{Declare delegate signatures.} In this case, we want the \code{Before} delegate signature to take two arguments: the original, unmodified yield and the one that will be returned from the \code{GetBaseExpYield} function.\\
	\begin{center}
		\includegraphics[scale=\ScreenshotScale]{create-outlet-signature}
	\end{center}
	You should also set the \code{After} signature in the same manner. \textit{Note: yours might use more than two parameters or different parameter types. Modify accordingly.}
	}
	\item{\textbf{Module API.} Make sure your module API is correct. If not, you'll get mysterious errors about your dll.
	\begin{center}
		\includegraphics[scale=\ScreenshotScale]{create-outlet-api}
	\end{center}
	}
	\item{\textbf{Declare \code{Outlet} functions.} In order to be able to call \code{ExecuteBefore} on your \code{Outlet}, you need to tell it a few things. The figure below displays a few things in red you should look at:\\
	\begin{center}
		\includegraphics[scale=\ScreenshotScale]{create-outlet-functions}
	\end{center}
		\begin{itemize}
			\item{Whether it's a \code{Before} or \code{After} type \code{Outlet}. This affects execution based on priority:
			\begin{tcolorbox}[colback=gray!20!white,colframe=blue!75!black,title=Priorities]
			
				The lower the priority, the farther away it is from execution. If two priorities are tied, the older effect is executed first. Order is set externally by \code{UEffectsComponent} \todo{fact check this}. Order:\\
				\begin{itemize}
					\item{Intrinsic \code{Before} delegates (no \code{UEffect} affiliated)}
					\item{\code{Before} delegates:
						\begin{itemize}
							\item{Priority 1}
							\item{Priority 2.a (older)}
							\item{Priority 2.b (newer)}
							\item{...}
						\end{itemize}
						}
					\item{[Function executes]}
					\item{\code{After} delegates:
						\begin{itemize}
							\item{...}
							\item{Priority 2.b (newer)}
							\item{Priority 2.a (older)}
							\item{Priority 1}
						\end{itemize}
						}
					\item{Intrinsic \code{After} delegates (have the final say)}
				\end{itemize}
				
			As an example, consider two delegates: one that says you can't take damage no matter what (call the \code{UBuff} ``Invincible'') and another that says damage against you can't be avoided no matter what (call the \code{UDebuff} ``Weakened''). What happens when the target takes damage? Well, it depends on priority:
			\begin{itemize}
				\item{They're probably subscribed to the \code{Before} delegate in \code{UStatsComponent} called \code{ModifyStatOutlet} with the target \code{FStat} being \code{Health}.}
				\item{Note that they're both \code{Before} delegates.}
				\item{Let's say Invincible has Priority 100 and Weakened has Priority 150. The result is the target takes damage because:
					\begin{enumerate}
						\item[1)]{Invincible first sets the damage to zero.}
						\item[2)]{Weakened then sets the damage to no less than its original value.}
					\end{enumerate}
				}
				\item{If Weakened has lower Priority, the result is flipped and the target takes no damage.}
			\end{itemize}
	 
	 \end{tcolorbox}\vspace*{12pt}
			}
			\item{The parameters you defined in the delegate's signature. I know, I know---anytime you repeat code, you're probably doing something wrong. The biggest issue here is the UHT. The main (but not only) issue is that you can't have \code{UPROPERTY}s inside macros or the property won't register. If you have a better way of automating this, \textit{tell me!}}
			\item{Don't forget the \code{After} variant's delegates, which should probably be \code{const}.}
		\end{itemize}
	}
	\item{\textbf{Check number of parameters.} I make a point of this because I find it's my most common error. Make sure your declared signature \textit{and} declared \code{Outlet} function macros have the correct number of params (two in our case). Explicitly, you might need to use \code{DECLARE\_DYNAMIC\_DELEGATE\_FourParams(...)}.}
	\item{\textbf{Declare \code{UPROPERTY}.} Inside the \code{UEffectableComponent} (in this example, \code{ULevelComponent}), declare the \code{Outlet} as a variable. Note that it's custom to have this \code{UPROPERTY} as public and in the ``Outlets'' category. It's also a good idea to comment the \code{UPROPERTY} with the parameters.
	\begin{center}
		\includegraphics[scale=\ScreenshotScale]{create-outlet-uproperty}
	\end{center}
	
	\textit{Note:} I use Rider, so it imports \code{\#include}s automatically. Make sure yours does, too.
	}
	\item{\textbf{Implement.} Now it's time to place your \code{Outlet} in the appropriate place(s). For our example, it's pretty simple: place it inside of \code{GetBaseExpYield} in \code{ULevelComponent}'s \code{.cpp} file.
	\begin{center}
		\includegraphics[scale=\ScreenshotScale]{create-outlet-cpp}
	\end{center}
	Note that you might have to do things like cache original values.
	}
	\item{\textbf{A note on complementary delegates.} If you create a \code{Before} \code{Outlet}, you should also create an \code{After} \code{Outlet}. The biggest difference might be the delegate signature (e.g., reference ``\code{\&}'' to \code{const}).
			
	An example where this would be necessary is an animation delegate. You only want to fire a ``bonus exp'' animation \textit{after} the amount of exp has been determined, checked, and is now constant.
	
	In some cases, it may not be necessary to have both \code{Before} and \code{After} delegates in a function. If you want only one delegate type, or three, or ten, the system is flexible enough to handle it. However, it's recommended to K.I.S.S.
	}
\end{enumerate}

\sect{Making Your Own Effects}

Suppose you want to make your own effect from scratch. \todo{todo}

\postamble{}